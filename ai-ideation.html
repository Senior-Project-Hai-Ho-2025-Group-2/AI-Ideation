<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AI Ideation</title>
<style>
  body{font-family:Arial,sans-serif;background:#f4f4f9;margin:0;padding:0;}
  .container{max-width:600px;margin:40px auto;padding:20px;background:#fff;box-shadow:0 4px 8px rgba(0,0,0,.1);border-radius:5px;}
  h1{font-size:1.8em;margin-bottom:20px;color:#333;}
  label{display:block;margin:12px 0 4px;font-weight:600;color:#555;}
  select,input{width:100%;padding:10px;border:1px solid #ddd;border-radius:4px;}
  .hidden{display:none;}
  button{margin-top:20px;padding:12px 24px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;}
  .results{margin-top:32px;}
  .project{border-bottom:1px solid #ddd;padding:12px 0;}
  #log{margin-top:24px;background:#f0f0f0;padding:8px;border-radius:4px;font-family:monospace;font-size:0.9em;height:120px;overflow:auto;}
  #spinner{display:none;margin:12px auto;width:24px;height:24px;border:4px solid #4CAF50;border-top:4px solid transparent;border-radius:50%;animation:spin 1s linear infinite;}
  @keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div class="container">
  <h1>AI Ideation</h1>
  <form id="problemForm">
    <label for="modelType">Select Model Type:</label>
    <select id="modelType" required onchange="handleModelType()">
      <option value="">-- choose --</option>
      <option value="openai">OpenAI</option>
      <option value="selfhosted">Self‑Hosted</option>
    </select>

    <div id="apiKeyField" class="hidden">
      <label for="apiKey">OpenAI API Key:</label>
      <input type="text" id="apiKey" placeholder="sk-..." autocomplete="off">
    </div>

    <div id="urlField" class="hidden">
      <label for="modelUrl">Self‑Hosted Base URL:</label>
      <input type="text" id="modelUrl" placeholder="http://192.168.1.10:11434" autocomplete="off" onblur="fetchModels()">
    </div>

    <div id="modelSelectField" class="hidden">
      <label for="modelSelect">Select Model:</label>
      <select id="modelSelect" required></select>
    </div>

    <label for="problem">Problem Statement:</label>
    <input type="text" id="problem" placeholder="Describe your problem..." required>

    <label for="budget">Budget (USD):</label>
    <input type="number" id="budget" min="0" placeholder="e.g., 5000" required>

    <button type="submit">Get Solutions</button>
  </form>

  <div id="spinner"></div>
  <div class="results" id="results"></div>
  <h2>Log</h2>
  <pre id="log"></pre>
</div>

<script>
/* ---------- Utility helpers ---------- */
function log(msg) {
  console.log(msg);
  const logEl = document.getElementById('log');
  logEl.textContent += msg + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}
function showSpinner(show) { document.getElementById('spinner').style.display = show ? 'block' : 'none'; }

/* ---------- Field visibility logic ---------- */
function handleModelType() {
  const type = document.getElementById('modelType').value;
  const apiField   = document.getElementById('apiKeyField');
  const urlField   = document.getElementById('urlField');
  const modelField = document.getElementById('modelSelectField');

  apiField.classList.add('hidden'); urlField.classList.add('hidden'); modelField.classList.add('hidden');

  if (type === 'openai') {
    apiField.classList.remove('hidden');
    document.getElementById('modelSelect').innerHTML = '<option value="gpt-3.5-turbo">gpt-3.5-turbo</option>';
    modelField.classList.remove('hidden');
    log('Model type: OpenAI; default model set to gpt‑3.5‑turbo');
  } else if (type === 'selfhosted') {
    urlField.classList.remove('hidden');
    log('Model type: Self‑Hosted; waiting for URL to fetch models');
  }
}

/* ---------- Fetch models from self‑hosted server ---------- */
async function fetchModels() {
  const url = document.getElementById('modelUrl').value.trim();
  if (!url) return;
  const urlPattern = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/;
  if (!urlPattern.test(url)) {
    alert('Please enter a valid URL (e.g., http://192.168.1.10:11434)');
    return;
  }

  log(`Fetching models from ${url}/api/tags`);
  showSpinner(true);
  try {
    const resp = await fetch(`${url}/api/tags`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();

    const select = document.getElementById('modelSelect');
    select.innerHTML = '';
    data.models.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.name;
      opt.textContent = m.name;
      select.appendChild(opt);
    });

    document.getElementById('modelSelectField').classList.remove('hidden');
    log(`Fetched ${data.models.length} models: ${data.models.map(m=>m.name).join(', ')}`);
  } catch (err) {
    console.error(err);
    log(`Error fetching models: ${err.message}`);
    alert('Could not fetch models. Check the URL and try again.');
  } finally { showSpinner(false); }
}

/* ---------- Stream handling with <think> logic ---------- */
let thinkBuffer = '';          // accumulated text since last <think>
let waitingForThink = false;   // true after we saw a <think>
let fullDisplayed = '';        // what we have shown so far

function flushThinkedText() {
  if (thinkBuffer) {
    fullDisplayed += thinkBuffer;
    document.getElementById('results').innerHTML =
      `<div class="project"><p>${fullDisplayed}</p></div>`;
    log(`Displayed text block (${thinkBuffer.length} chars)`);
    thinkBuffer = '';
  }
}

function handleChunkContent(content) {
  // Append new content to buffer
  thinkBuffer += content;

  // Process every <think> tag that appears
  while (thinkBuffer.includes('<think>')) {
    const idx = thinkBuffer.indexOf('<think>');
    if (waitingForThink) {
      // We had a <think> before – display everything up to this new one
      const toShow = thinkBuffer.slice(0, idx);
      thinkBuffer = thinkBuffer.slice(idx + '<think>'.length);
      // Show what we had accumulated
      fullDisplayed += toShow;
      document.getElementById('results').innerHTML =
        `<div class="project"><p>${fullDisplayed}</p></div>`;
      log(`Flushed block (${toShow.length} chars)`);
      waitingForThink = false; // now waiting for next <think>
    } else {
      // First <think> seen – discard everything before it
      thinkBuffer = thinkBuffer.slice(idx + '<think>'.length);
      waitingForThink = true;
      log('Encountered first <think> – buffering until next');
    }
  }
}

/* ---------- Form submission ---------- */
document.getElementById('problemForm').addEventListener('submit', async e => {
  e.preventDefault();

  const type    = document.getElementById('modelType').value;
  const model   = document.getElementById('modelSelect').value;
  const problem = document.getElementById('problem').value.trim();
  const budget  = document.getElementById('budget').value.trim();

  if (!model || !problem || !budget) {
    alert('Please select a model, enter a problem statement, and set a budget.');
    return;
  }

  log(`Submitting problem: "${problem}" with budget $${budget} to model "${model}" (${type})`);
  showSpinner(true);
  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '';
  thinkBuffer = ''; waitingForThink = false; fullDisplayed = '';

  try {
    let url, headers;
    if (type === 'openai') {
      const apiKey = document.getElementById('apiKey').value.trim();
      if (!apiKey) { alert('Please provide your OpenAI API key.'); return; }
      url = 'https://api.openai.com/v1/chat/completions';
      headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      };
      log('Using OpenAI endpoint (no streaming in this demo)');
    } else if (type === 'selfhosted') {
      const base = document.getElementById('modelUrl').value.trim();
      url = `${base}/api/chat`;
      headers = {'Content-Type': 'application/json'};
      log(`Using self‑hosted endpoint: ${url}`);
    } else {
      alert('Please select a model type.');
      return;
    }

    const body = JSON.stringify({
      model,
      messages: [{role:"user", content:`Come up with possible engineering projects that solve: ${problem}. Aim to stay within the budget of $${budget}.`}]
    });

    log(`Request body: ${body}`);
    const resp = await fetch(url, {method:'POST', headers, body});
    if (!resp.ok) throw new Error(`Request failed (${resp.status})`);

    const decoder = new TextDecoder();
    const reader  = resp.body.getReader();

    // Stream the response, processing <think> tags
    while (true) {
      const {value, done} = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, {stream:true});
      log(`Received chunk (${chunk.length} chars)`);
      // Ollama streams newline‑delimited JSON objects
      const parts = chunk.split(/\n/).filter(Boolean);
      for (const part of parts) {
        try {
          const obj = JSON.parse(part);
          if (obj.message && obj.message.content) {
            handleChunkContent(obj.message.content);
          }
        } catch (e) {
          log(`Failed to parse chunk: ${part}`);
        }
      }
    }

    // Flush anything left after stream ends
    flushThinkedText();
    log('Streaming complete');
  } catch (err) {
    console.error(err);
    log(`Error: ${err.message}`);
    resultsDiv.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
  } finally {
    showSpinner(false);
  }
});
</script>
</body>
</html>
